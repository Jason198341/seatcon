/**
 * 컨퍼런스 채팅 애플리케이션 - 메인 로직
 * 
 * 고급 UX/UI와 다국어 번역을 지원하는 실시간 채팅 애플리케이션의 메인 스크립트입니다.
 * 사용자 인터페이스와 데이터베이스 서비스를 조정하여 원활한 채팅 경험을 제공합니다.
 */
class App {
    constructor() {
        // 애플리케이션 상태
        this.state = {
            currentScreen: 'role-screen',
            userRole: 'participant',
            typingTimeout: null,
            latestMessageTimestamp: null,
            onlineUsers: []
        };
        
        // 모더레이터 비밀번호
        this.moderatorPassword = '9881';
        
        // 초기화
        this.init();
    }
    
    /**
     * 애플리케이션 초기화
     */
    async init() {
        console.log('컨퍼런스 채팅 애플리케이션 초기화');
        
        // 데이터베이스 연결 테스트
        await this.testDatabaseConnection();
        
        // 이벤트 리스너 설정
        this.setupEventListeners();
        
        // 저장된 사용자 세션 확인
        this.checkExistingSession();
    }
    
    /**
     * 데이터베이스 연결 테스트
     */
    async testDatabaseConnection() {
        try {
            uiController.showLoading('데이터베이스 연결 중...');
            
            const isConnected = await databaseService.testConnection();
            
            if (!isConnected) {
                throw new Error('데이터베이스 연결 실패');
            }
            
            // 번역 서비스 테스트
            const isTranslationWorking = await translationService.testTranslation();
            
            if (!isTranslationWorking) {
                console.warn('번역 서비스 초기화 실패. 기본 언어로만 표시됩니다.');
            }
            
            uiController.hideLoading();
        } catch (error) {
            console.error('초기화 오류:', error);
            uiController.hideLoading();
            uiController.showToast('서비스 연결에 문제가 있습니다. 나중에 다시 시도해주세요.', 'error');
        }
    }
    
    /**
     * 이벤트 리스너 설정
     */
    setupEventListeners() {
        // 역할 선택 화면
        document.getElementById('participant-role').addEventListener('click', () => this.handleRoleSelect('participant'));
        document.getElementById('moderator-role').addEventListener('click', () => this.handleRoleSelect('moderator'));
        
        // 진행자 비밀번호 화면
        document.getElementById('close-password').addEventListener('click', this.hideModeratorPassword.bind(this));
        document.getElementById('confirm-password').addEventListener('click', this.verifyModeratorPassword.bind(this));
        
        // 비밀번호 입력 필드 이벤트
        const passwordDigits = document.querySelectorAll('.password-digit');
        passwordDigits.forEach(digit => {
            digit.addEventListener('input', this.handlePasswordDigitInput.bind(this));
            digit.addEventListener('keydown', this.handlePasswordDigitKeydown.bind(this));
        });
        
        // 프로필 설정 화면
        document.getElementById('profile-form').addEventListener('submit', this.handleProfileSubmit.bind(this));
        
        // 채팅 화면
        document.getElementById('message-input').addEventListener('keydown', this.handleMessageKeydown.bind(this));
        document.getElementById('message-input').addEventListener('input', this.handleMessageInput.bind(this));
        document.getElementById('send-button').addEventListener('click', this.sendMessage.bind(this));
        
        // 설정 메뉴
        document.getElementById('settings-button').addEventListener('click', () => uiController.showPanel('settings-panel'));
        document.getElementById('close-settings').addEventListener('click', () => uiController.hidePanel('settings-panel'));
        document.getElementById('logout-button').addEventListener('click', this.handleLogout.bind(this));
        document.getElementById('settings-language').addEventListener('change', this.handleLanguageChange.bind(this));
        
        // 진행자 도구
        const announcementButton = document.getElementById('announcement-button');
        if (announcementButton) {
            announcementButton.addEventListener('click', () => uiController.showPanel('announcement-panel'));
        }
        
        const kickUserButton = document.getElementById('kick-user-button');
        if (kickUserButton) {
            kickUserButton.addEventListener('click', () => this.openKickPanel());
        }
        
        // 공지사항 패널
        document.getElementById('close-announcement').addEventListener('click', () => uiController.hidePanel('announcement-panel'));
        document.getElementById('send-announcement').addEventListener('click', this.sendAnnouncement.bind(this));
        
        // 강퇴 패널
        document.getElementById('close-kick').addEventListener('click', () => uiController.hidePanel('kick-panel'));
        
        // 스크롤 하단 버튼
        document.getElementById('scroll-bottom-button').addEventListener('click', () => uiController.scrollToBottom());
        
        // 윈도우 이벤트
        window.addEventListener('beforeunload', this.handleBeforeUnload.bind(this));
        window.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));
        
        // 네트워크 상태 이벤트
        window.addEventListener('online', () => {
            console.log('인터넷 연결이 복원되었습니다.');
            uiController.showToast('인터넷 연결이 복원되었습니다.', 'success');
            
            // 연결 상태 정보 업데이트
            if (window.connectionStatusIndicator) {
                connectionStatusIndicator.updateStatus('connected');
            }
            
            // 메시지 다시 로드
            this.loadMessages();
            
            // 메시지 구독 재설정
            if (databaseService.currentUser) {
                databaseService.subscribeToMessages(this.handleNewMessage.bind(this));
                
                // 브로드캐스트 채널 설정
                databaseService.setupBroadcastChannel();
            }
        });
        
        window.addEventListener('offline', () => {
            console.log('인터넷 연결이 끊겼습니다.');
            uiController.showToast('인터넷 연결이 끊겼습니다. 메시지는 자동으로 대기열에 추가됩니다.', 'warning');
            
            // 연결 상태 정보 업데이트
            if (window.connectionStatusIndicator) {
                connectionStatusIndicator.updateStatus('disconnected');
            }
        });
    }
    
    /**
     * 기존 사용자 세션 확인
     */
    checkExistingSession() {
        const savedUser = databaseService.getSavedUserInfo();
        
        if (savedUser) {
            // 강퇴 여부 확인
            databaseService.checkIfKicked().then(isKicked => {
                if (isKicked) {
                    // 강퇴된 사용자라면 세션 정보 삭제
                    databaseService.clearUserInfo();
                    uiController.showToast('강퇴되어 채팅에 참여할 수 없습니다.', 'error');
                    return;
                }
                
                // 사용자 정보 복원
                this.state.userRole = savedUser.isModerator ? 'moderator' : 'participant';
                
                // 채팅 화면으로 이동
                this.openChatScreen();
            });
        }
    }
    
    /**
     * 역할 선택 처리
     * @param {string} role - 선택한 역할 ('participant' 또는 'moderator')
     */
    handleRoleSelect(role) {
        if (role === 'participant') {
            this.state.userRole = 'participant';
            uiController.changeScreen('profile-screen');
            
            // 프로필 뱃지 업데이트
            const roleBadge = document.getElementById('profile-role-badge');
            roleBadge.innerHTML = '<i class="fas fa-user"></i><span>참가자</span>';
            roleBadge.classList.remove('moderator');
        } else if (role === 'moderator') {
            this.state.userRole = 'moderator';
            this.showModeratorPassword();
        }
    }
    
    /**
     * 진행자 비밀번호 화면 표시
     */
    showModeratorPassword() {
        const passwordContainer = document.getElementById('moderator-password');
        
        // 에러 메시지 숨기기
        document.getElementById('password-error-message').style.display = 'none';
        
        // 입력 필드 초기화
        const passwordDigits = document.querySelectorAll('.password-digit');
        passwordDigits.forEach(digit => {
            digit.value = '';
        });
        
        // 첫 번째 입력 필드에 포커스
        setTimeout(() => {
            passwordDigits[0].focus();
        }, 300);
        
        // 비밀번호 컨테이너 표시
        passwordContainer.classList.remove('hidden');
        
        // 애니메이션 적용
        animationsController.animate('zoomIn', passwordContainer);
    }
    
    /**
     * 진행자 비밀번호 화면 숨기기
     */
    hideModeratorPassword() {
        const passwordContainer = document.getElementById('moderator-password');
        
        // 애니메이션 적용 후 숨기기
        animationsController.animate('zoomOut', passwordContainer, {
            onComplete: () => {
                passwordContainer.classList.add('hidden');
            }
        });
    }
    
    /**
     * 비밀번호 입력 필드 처리
     * @param {Event} event - 입력 이벤트
     */
    handlePasswordDigitInput(event) {
        const input = event.target;
        const index = parseInt(input.dataset.index);
        
        // 숫자만 허용
        input.value = input.value.replace(/[^0-9]/g, '');
        
        // 값이 입력되면 다음 필드로 이동
        if (input.value.length > 0 && index < 3) {
            const nextInput = document.querySelector(`.password-digit[data-index="${index + 1}"]`);
            if (nextInput) {
                nextInput.focus();
            }
        }
        
        // 모든 필드가 입력되었는지 확인
        const allFilled = Array.from(document.querySelectorAll('.password-digit'))
            .every(digit => digit.value.length > 0);
        
        if (allFilled) {
            this.verifyModeratorPassword();
        }
    }
    
    /**
     * 비밀번호 입력 필드 키 이벤트 처리
     * @param {KeyboardEvent} event - 키보드 이벤트
     */
    handlePasswordDigitKeydown(event) {
        const input = event.target;
        const index = parseInt(input.dataset.index);
        
        // 백스페이스 처리
        if (event.key === 'Backspace') {
            if (input.value.length === 0 && index > 0) {
                // 현재 필드가 비어있으면 이전 필드로 이동
                const prevInput = document.querySelector(`.password-digit[data-index="${index - 1}"]`);
                if (prevInput) {
                    prevInput.focus();
                    prevInput.value = '';
                }
            }
        }
    }
    
    /**
     * 진행자 비밀번호 확인
     */
    verifyModeratorPassword() {
        const enteredPassword = Array.from(document.querySelectorAll('.password-digit'))
            .map(digit => digit.value)
            .join('');
        
        if (enteredPassword === this.moderatorPassword) {
            // 비밀번호 정확
            this.hideModeratorPassword();
            
            // 프로필 화면으로 이동
            uiController.changeScreen('profile-screen');
            
            // 프로필 뱃지 업데이트
            const roleBadge = document.getElementById('profile-role-badge');
            roleBadge.innerHTML = '<i class="fas fa-user-tie"></i><span>진행자</span>';
            roleBadge.classList.add('moderator');
        } else {
            // 비밀번호 불일치
            const errorMessage = document.getElementById('password-error-message');
            errorMessage.style.display = 'block';
            
            // 애니메이션 적용
            animationsController.animate('shake', document.querySelector('.password-digits'));
            
            // 입력 필드 초기화
            document.querySelectorAll('.password-digit').forEach(digit => {
                digit.value = '';
            });
            
            // 첫 번째 입력 필드에 포커스
            document.querySelector('.password-digit[data-index="0"]').focus();
        }
    }
    
    /**
     * 프로필 제출 처리
     * @param {Event} event - 폼 제출 이벤트
     */
    async handleProfileSubmit(event) {
        event.preventDefault();
        
        // 입력값 가져오기
        const name = document.getElementById('user-name').value.trim();
        const email = document.getElementById('user-email').value.trim();
        const language = document.getElementById('preferred-language').value;
        
        if (!name || !email) {
            uiController.showToast('모든 필드를 입력해주세요.', 'warning');
            return;
        }
        
        // 이메일 형식 검사
        const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailPattern.test(email)) {
            uiController.showToast('유효한 이메일 주소를 입력해주세요.', 'warning');
            return;
        }
        
        try {
            uiController.showLoading('채팅에 참여하는 중...');
            
            // 강퇴 여부 확인
            const isKicked = await databaseService.checkIfKicked();
            
            if (isKicked) {
                uiController.hideLoading();
                uiController.showToast('강퇴되어 채팅에 참여할 수 없습니다.', 'error');
                return;
            }
            
            // 사용자 정보 저장
            const userInfo = {
                name: name,
                email: email,
                language: language,
                isModerator: this.state.userRole === 'moderator'
            };
            
            databaseService.saveUserInfo(userInfo);
            
            // 채팅 화면으로 이동
            this.openChatScreen();
        } catch (error) {
            console.error('프로필 저장 오류:', error);
            uiController.hideLoading();
            uiController.showToast('프로필 저장 중 오류가 발생했습니다.', 'error');
        }
    }
    
    /**
     * 채팅 화면 열기
     */
    async openChatScreen() {
        try {
            // 채팅 화면으로 전환
            uiController.changeScreen('chat-screen');
            
            // 역할 뱃지 업데이트
            const roleBadge = document.getElementById('chat-role-badge');
            
            if (databaseService.currentUser.isModerator) {
                roleBadge.innerHTML = '<i class="fas fa-user-tie"></i><span>진행자</span>';
                roleBadge.classList.add('moderator');
                
                // 진행자 도구 표시
                document.getElementById('moderator-tools').classList.remove('hidden');
            } else {
                roleBadge.innerHTML = '<i class="fas fa-user"></i><span>참가자</span>';
                roleBadge.classList.remove('moderator');
                
                // 진행자 도구 숨기기
                const moderatorTools = document.getElementById('moderator-tools');
                if (moderatorTools) {
                    moderatorTools.classList.add('hidden');
                }
            }
            
            // 설정의 언어 옵션 동기화
            const settingsLanguage = document.getElementById('settings-language');
            settingsLanguage.value = databaseService.currentUser.language;
            
            // 이전 메시지 로드
            this.loadMessages();
            
            // 메시지 구독 시작
            databaseService.subscribeToMessages(this.handleNewMessage.bind(this));
            
            // 브로드캐스트 채널 설정 (새로 추가)
            databaseService.setupBroadcastChannel();
            
            // 네트워크 상태 표시기 초기화 (새로 추가)
            if (window.connectionStatusIndicator) {
                connectionStatusIndicator.updateSettings({
                    position: 'top',
                    autoHide: true,
                    showOnlineStatus: true
                });
                
                // 현재 연결 상태 표시
                connectionStatusIndicator.updateStatus(navigator.onLine ? 'connected' : 'disconnected');
            }
            
            // 진입 메시지 표시
            uiController.addSystemMessage(`${databaseService.currentUser.name}님이 채팅에 참여했습니다.`);
            
            // 로딩 숨기기
            uiController.hideLoading();
            
            // 웰컴 토스트 표시
            uiController.showToast(`환영합니다, ${databaseService.currentUser.name}님!`, 'success');
        } catch (error) {
            console.error('채팅 화면 열기 오류:', error);
            uiController.hideLoading();
            uiController.showToast('채팅 초기화 중 오류가 발생했습니다.', 'error');
        }
    }
    
    /**
     * 이전 메시지 로드
     */
    async loadMessages() {
        try {
            uiController.showLoading('메시지를 로드하는 중...');
            
            const messages = await databaseService.getRecentMessages();
            
            if (messages && messages.length > 0) {
                // 최신 메시지 타임스탬프 설정
                this.state.latestMessageTimestamp = new Date(messages[messages.length - 1].created_at);
                
                // 메시지 추가
                for (const message of messages) {
                    // 번역 처리
                    if (databaseService.currentUser.language !== message.language) {
                        try {
                            const translatedContent = await translationService.translateText(
                                message.content,
                                message.language,
                                databaseService.currentUser.language
                            );
                            
                            message.translatedContent = translatedContent;
                            message.targetLanguage = databaseService.currentUser.language;
                        } catch (error) {
                            console.error('메시지 번역 오류:', error);
                        }
                    }
                    
                    // 자신의 메시지 여부 확인
                    const isOwnMessage = message.user_id === databaseService.currentUser.email;
                    
                    // UI에 메시지 추가
                    uiController.addMessage(message, isOwnMessage);
                }
                
                // 스크롤을 하단으로
                uiController.scrollToBottom(false);
            } else {
                // 메시지가 없는 경우
                uiController.addSystemMessage('채팅에 오신 것을 환영합니다! 첫 메시지를 보내보세요.');
            }
            
            uiController.hideLoading();
        } catch (error) {
            console.error('메시지 로드 오류:', error);
            uiController.hideLoading();
            uiController.showToast('메시지를 로드하는 중 오류가 발생했습니다.', 'error');
            
            // 오류 메시지 표시
            uiController.addSystemMessage('메시지를 불러오지 못했습니다. 페이지를 새로고침해 주세요.');
        }
    }
    
    /**
     * 메시지 전송
     */
    async sendMessage() {
        if (!databaseService.currentUser) {
            uiController.showToast('로그인 정보가 없습니다. 다시 로그인해주세요.', 'error');
            return;
        }
        
        const messageInput = document.getElementById('message-input');
        const content = messageInput.value.trim();
        
        if (!content) return;
        
        try {
            // 입력 필드 초기화
            messageInput.value = '';
            
            // 자동 높이 조절 적용
            uiController.autoResizeTextarea(messageInput);
            
            // 입력 중 상태 취소
            this.clearTypingStatus();
            
            // 메시지 전송
            const message = await databaseService.sendMessage(content);
            
            if (!message) {
                throw new Error('메시지 전송 실패');
            }
            
            // 최신 메시지 타임스탬프 업데이트
            this.state.latestMessageTimestamp = new Date(message.created_at);
            
            // UI에 스크롤이 자동으로 이동함 (handleNewMessage에서 처리)
        } catch (error) {
            console.error('메시지 전송 오류:', error);
            
            // 메시지가 큐에 들어간 경우는 오류 메시지를 표시하지 않음
            if (!error.message.includes('queued')) {
                uiController.showToast('메시지 전송에 실패했습니다.', 'error');
                
                // 입력 내용 복원
                messageInput.value = content;
            }
        }
    }
    
    /**
     * 새 메시지 처리
     * @param {Object} message - 메시지 객체
     */
    handleNewMessage(message) {
        if (!message) return;
        
        // 자신의 메시지 여부 확인
        const isOwnMessage = message.user_id === databaseService.currentUser.email;
        
        // 임시 메시지 체크
        const isTempMessage = message.isTemp === true;
        
        // 이미 표시된 임시 메시지인 경우 UI 업데이트만 수행
        if (isOwnMessage && !isTempMessage && message.client_id) {
            // 이미 임시 메시지가 표시되어 있는 경우, UI 업데이트만 수행
            const tempMessageElement = document.querySelector(`[data-message-id="${message.client_id}"]`);
            if (tempMessageElement) {
                // 상태 업데이트 (전송 중 -> 전송 완료)
                if (window.messageStatusManager) {
                    messageStatusManager.updateMessageStatus(message.client_id, 'delivered');
                }
                return; // 이미 메시지가 표시되어 있으므로 추가 처리 불필요
            }
        }
        
        // UI에 메시지 추가 (임시 메시지가 아니거나, 표시되지 않은 경우)
        uiController.addMessage(message, isOwnMessage);
        
        // 메시지 추가 후 스크롤 자동 조정
        // 자신의 메시지 또는 화면 하단에 있는 경우 스크롤 다운
        const chatMessages = document.querySelector('.chat-messages');
        const isAtBottom = chatMessages.scrollHeight - chatMessages.scrollTop - chatMessages.clientHeight < 100;
        
        if (isOwnMessage || isAtBottom) {
            uiController.scrollToBottom();
        } else if (!isOwnMessage && !isAtBottom) {
            // 새 메시지 알림 표시 (화면 하단에 있지 않은 경우)
            uiController.showNewMessageNotification();
        }
        
        // 상대방 메시지가 왔을 때 소리 또는 알림
        if (!isOwnMessage && !isTempMessage) {
            this.notifyNewMessage(message);
        }
    }
    
    /**
     * 새 메시지 알림
     * @param {Object} message - 메시지 객체
     */
    notifyNewMessage(message) {
        // 페이지가 포커스되어 있지 않은 경우 브라우저 알림
        if (document.visibilityState !== 'visible') {
            this.showBrowserNotification(message);
        }
        
        // 소리 알림 (필요한 경우 여기에 추가)
        if (window.notificationSound) {
            notificationSound.play();
        }
    }
    
    /**
     * 브라우저 알림 표시
     * @param {Object} message - 메시지 객체
     */
    showBrowserNotification(message) {
        if ('Notification' in window && Notification.permission === 'granted') {
            const title = message.is_announcement 
                ? '새 공지사항' 
                : `${message.user_name}님의 메시지`;
            
            const options = {
                body: message.content,
                icon: '/assets/images/notification-icon.png',
                badge: '/assets/images/notification-badge.png'
            };
            
            new Notification(title, options);
        } else if ('Notification' in window && Notification.permission !== 'denied') {
            // 알림 권한 요청
            Notification.requestPermission();
        }
    }
    
    /**
     * 공지사항 전송
     */
    async sendAnnouncement() {
        if (!databaseService.currentUser || !databaseService.currentUser.isModerator) {
            uiController.showToast('진행자만 공지사항을 등록할 수 있습니다.', 'warning');
            return;
        }
        
        const announcementText = document.getElementById('announcement-text');
        const content = announcementText.value.trim();
        
        if (!content) {
            uiController.showToast('공지사항 내용을 입력해주세요.', 'warning');
            return;
        }
        
        try {
            // 패널 닫기
            uiController.hidePanel('announcement-panel');
            
            // 입력 필드 초기화
            announcementText.value = '';
            
            // 공지사항 전송
            await databaseService.sendMessage(content, true);
            
            // 토스트 표시
            uiController.showToast('공지사항이 등록되었습니다.', 'success');
        } catch (error) {
            console.error('공지사항 등록 오류:', error);
            uiController.showToast('공지사항 등록에 실패했습니다.', 'error');
            
            // 입력 내용 복원 및 패널 다시 열기
            announcementText.value = content;
            uiController.showPanel('announcement-panel');
        }
    }
    
    /**
     * 강퇴 패널 열기
     */
    async openKickPanel() {
        if (!databaseService.currentUser || !databaseService.currentUser.isModerator) {
            uiController.showToast('진행자만 사용할 수 있는 기능입니다.', 'warning');
            return;
        }
        
        try {
            // 패널 표시
            uiController.showPanel('kick-panel');
            
            // 사용자 목록 가져오기
            const users = await this.getActiveUsers();
            
            // 사용자 목록 표시
            this.renderUserList(users);
        } catch (error) {
            console.error('사용자 목록 로드 오류:', error);
            uiController.showToast('사용자 목록을 불러오는 중 오류가 발생했습니다.', 'error');
            
            // 패널 닫기
            uiController.hidePanel('kick-panel');
        }
    }
    
    /**
     * 활성 사용자 목록 가져오기
     * @returns {Promise<Array>} - 사용자 목록
     */
    async getActiveUsers() {
        try {
            // 온라인 사용자 목록 활용 (있는 경우)
            if (databaseService.onlineUsers && databaseService.onlineUsers.size > 0) {
                const users = Array.from(databaseService.onlineUsers.values()).map(user => ({
                    email: user.user_id,
                    name: user.user_name,
                    isModerator: user.is_moderator
                }));
                
                // 자신은 제외
                return users.filter(user => user.email !== databaseService.currentUser.email);
            }
            
            // 온라인 사용자 목록이 없으면 메시지를 보낸 사용자 목록을 가져옴
            const messages = await databaseService.getRecentMessages(100);
            
            // 중복 제거 (이메일 기준)
            const uniqueUsers = [];
            const userEmails = new Set();
            
            for (const message of messages) {
                if (!userEmails.has(message.user_id) && 
                    message.user_id !== databaseService.currentUser.email) {
                    userEmails.add(message.user_id);
                    
                    uniqueUsers.push({
                        email: message.user_id,
                        name: message.user_name,
                        isModerator: message.is_moderator
                    });
                }
            }
            
            return uniqueUsers;
        } catch (error) {
            console.error('사용자 목록 가져오기 오류:', error);
            return [];
        }
    }
    
    /**
     * 사용자 목록 렌더링
     * @param {Array} users - 사용자 목록
     */
    renderUserList(users) {
        const userList = document.getElementById('user-list');
        
        // 목록 초기화
        userList.innerHTML = '';
        
        if (users.length === 0) {
            // 사용자가 없는 경우
            userList.innerHTML = '<p class="empty-list">현재 채팅에 참여한 사용자가 없습니다.</p>';
            return;
        }
        
        // 사용자 목록 렌더링
        users.forEach(user => {
            // 진행자는 강퇴 대상에서 제외
            if (user.isModerator) return;
            
            const userItem = document.createElement('div');
            userItem.classList.add('user-item');
            
            userItem.innerHTML = `
                <div class="user-info">
                    <div class="user-name">${user.name}</div>
                    <div class="user-email">${user.email}</div>
                </div>
                <button class="btn btn-sm btn-danger kick-button" data-email="${user.email}" data-name="${user.name}">강퇴</button>
            `;
            
            userList.appendChild(userItem);
        });
        
        // 강퇴 버튼 이벤트 리스너 추가
        userList.querySelectorAll('.kick-button').forEach(button => {
            button.addEventListener('click', (event) => {
                const email = event.target.dataset.email;
                const name = event.target.dataset.name;
                
                if (email && name) {
                    this.confirmKickUser(email, name);
                }
            });
        });
    }
    
    /**
     * 사용자 강퇴 확인
     * @param {string} email - 사용자 이메일
     * @param {string} name - 사용자 이름
     */
    confirmKickUser(email, name) {
        // 확인 토스트
        if (confirm(`${name}님을 강퇴하시겠습니까?`)) {
            this.kickUser(email, name);
        }
    }
    
    /**
     * 사용자 강퇴
     * @param {string} email - 사용자 이메일
     * @param {string} name - 사용자 이름
     */
    async kickUser(email, name) {
        if (!databaseService.currentUser || !databaseService.currentUser.isModerator) {
            uiController.showToast('진행자만 사용할 수 있는 기능입니다.', 'warning');
            return;
        }
        
        try {
            // 강퇴 처리
            const success = await databaseService.kickUser(email);
            
            if (success) {
                uiController.showToast(`${name}님을 강퇴했습니다.`, 'success');
                
                // 강퇴 패널 닫기
                uiController.hidePanel('kick-panel');
            } else {
                throw new Error('강퇴 처리 실패');
            }
        } catch (error) {
            console.error('사용자 강퇴 오류:', error);
            uiController.showToast('사용자 강퇴 중 오류가 발생했습니다.', 'error');
        }
    }
    
    /**
     * 메시지 입력 키 이벤트 처리
     * @param {KeyboardEvent} event - 키보드 이벤트
     */
    handleMessageKeydown(event) {
        // Shift + Enter는 줄바꿈, Enter는 전송
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            this.sendMessage();
        }
    }
    
    /**
     * 메시지 입력 이벤트 처리
     */
    handleMessageInput() {
        // 자동 높이 조절
        const messageInput = document.getElementById('message-input');
        uiController.autoResizeTextarea(messageInput);
        
        // 입력 중 상태 업데이트
        this.updateTypingStatus();
    }
    
    /**
     * 입력 중 상태 업데이트
     */
    updateTypingStatus() {
        // 입력 중 상태 브로드캐스트 (추가)
        if (databaseService.broadcastChannel) {
            databaseService.broadcastTypingStatus(true);
        }
        
        // 기존 타이머 취소
        if (this.state.typingTimeout) {
            clearTimeout(this.state.typingTimeout);
        }
        
        // 새 타이머 설정
        this.state.typingTimeout = setTimeout(() => {
            this.clearTypingStatus();
        }, 3000);
    }
    
    /**
     * 입력 중 상태 취소
     */
    clearTypingStatus() {
        if (this.state.typingTimeout) {
            clearTimeout(this.state.typingTimeout);
            this.state.typingTimeout = null;
        }
        
        // 입력 중 상태 브로드캐스트 (추가)
        if (databaseService.broadcastChannel) {
            databaseService.broadcastTypingStatus(false);
        }
    }
    
    /**
     * 언어 변경 처리
     */
    async handleLanguageChange() {
        if (!databaseService.currentUser) return;
        
        const newLanguage = document.getElementById('settings-language').value;
        const currentLanguage = databaseService.currentUser.language;
        
        if (newLanguage === currentLanguage) return;
        
        try {
            // 로딩 표시
            uiController.showLoading('언어 설정 변경 중...');
            
            // 사용자 정보 업데이트
            databaseService.currentUser.language = newLanguage;
            databaseService.saveUserInfo(databaseService.currentUser);
            
            // 메시지 컨테이너 초기화
            document.getElementById('message-container').innerHTML = '';
            
            // 메시지 다시 로드
            await this.loadMessages();
            
            // 로딩 숨기기
            uiController.hideLoading();
            
            // 토스트 표시
            uiController.showToast('언어 설정이 변경되었습니다.', 'success');
        } catch (error) {
            console.error('언어 변경 오류:', error);
            uiController.hideLoading();
            uiController.showToast('언어 설정 변경 중 오류가 발생했습니다.', 'error');
        }
    }
    
    /**
     * 로그아웃 처리
     * 사용자 세션 정보가 완전히 제거되도록 개선
     */
    handleLogout() {
        // 구독 해제
        databaseService.unsubscribeAll();
        
        // 사용자 정보 삭제
        databaseService.clearUserInfo();
        
        // 로컬 스토리지에서 모든 세션 관련 데이터 삭제
        localStorage.removeItem('conferenceUserInfo');
        localStorage.removeItem('messageQueue');
        localStorage.removeItem('translationCache');
        
        // 세션 스토리지도 정리
        sessionStorage.clear();
        
        // 메시지 컨테이너 초기화
        document.getElementById('message-container').innerHTML = '';
        
        // 상태 초기화
        this.state = {
            currentScreen: 'role-screen',
            userRole: 'participant',
            typingTimeout: null,
            latestMessageTimestamp: null,
            onlineUsers: []
        };
        
        // 모듈 초기화
        this.resetModules();
        
        // 시작 화면으로 이동
        uiController.changeScreen('role-screen', true);
        
        // 토스트 표시
        uiController.showToast('채팅을 종료했습니다. 재입장이 가능합니다.', 'info');
        
        console.log('모든 세션 정보가 초기화되었습니다. 재입장이 가능합니다.');
    }
    
    /**
     * 외부 모듈 초기화
     */
    resetModules() {
        // 메시지 상태 관리자 초기화
        if (window.messageStatusManager) {
            // 내부 상태 초기화
            messageStatusManager.messageStatusMap.clear();
            messageStatusManager.tempToRealIdMap.clear();
            messageStatusManager.retryQueue = [];
            
            // 타이머 정리
            if (messageStatusManager.retryTimer) {
                clearInterval(messageStatusManager.retryTimer);
                messageStatusManager.retryTimer = null;
            }
        }
        
        // 타이핑 인디케이터 초기화
        if (window.typingIndicatorManager) {
            // 내부 상태 초기화
            typingIndicatorManager.typingUsers.clear();
            typingIndicatorManager.isTyping = false;
            
            // 타이머 정리
            if (typingIndicatorManager.typingTimer) {
                clearTimeout(typingIndicatorManager.typingTimer);
                typingIndicatorManager.typingTimer = null;
            }
            
            if (typingIndicatorManager.displayTimer) {
                clearInterval(typingIndicatorManager.displayTimer);
                typingIndicatorManager.displayTimer = null;
            }
            
            // UI 정리
            typingIndicatorManager.hideTypingIndicator();
        }
        
        // 연결 상태 표시기 초기화
        if (window.connectionStatusIndicator) {
            // UI 숨기기
            connectionStatusIndicator.hideIndicator();
        }
    }
    
    /**
     * 페이지 언로드 처리
     */
    handleBeforeUnload() {
        // 구독 해제
        databaseService.unsubscribeAll();
    }
    
    /**
     * 페이지 가시성 변경 처리
     */
    handleVisibilityChange() {
        if (document.visibilityState === 'visible') {
            // 페이지가 활성화되면 새 메시지가 있는지 확인
            if (this.state.latestMessageTimestamp) {
                this.checkNewMessages();
            }
        }
    }
    
    /**
     * 새 메시지 확인
     */
    async checkNewMessages() {
        try {
            // 최신 메시지 가져오기
            const messages = await databaseService.getRecentMessages(10);
            
            if (messages && messages.length > 0) {
                const latestMessage = messages[messages.length - 1];
                const latestTimestamp = new Date(latestMessage.created_at);
                
                // 현재 저장된 최신 메시지보다 새로운 메시지가 있는지 확인
                if (latestTimestamp > this.state.latestMessageTimestamp) {
                    this.state.latestMessageTimestamp = latestTimestamp;
                    
                    // 새 메시지 알림
                    uiController.showNewMessageNotification();
                }
            }
        } catch (error) {
            console.error('새 메시지 확인 오류:', error);
        }
    }
}

// 애플리케이션 인스턴스 생성 및 시작
document.addEventListener('DOMContentLoaded', () => {
    window.app = new App();
});
