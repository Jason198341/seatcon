/**
 * 애니메이션 컨트롤러
 * 
 * 고품질 애니메이션과 전환을 관리하는 클래스입니다.
 * 부드럽고 자연스러운 인터페이스 전환을 위한 다양한 애니메이션을 제공합니다.
 */
class AnimationsController {
    constructor() {
        // 애니메이션 매핑
        this.animations = {
            // 페이드 애니메이션
            fadeIn: {
                keyframes: [
                    { opacity: 0 },
                    { opacity: 1 }
                ],
                options: {
                    duration: 300,
                    easing: 'ease-out',
                    fill: 'forwards'
                }
            },
            fadeOut: {
                keyframes: [
                    { opacity: 1 },
                    { opacity: 0 }
                ],
                options: {
                    duration: 300,
                    easing: 'ease-in',
                    fill: 'forwards'
                }
            },
            
            // 슬라이드 애니메이션
            slideInLeft: {
                keyframes: [
                    { transform: 'translateX(-20px)', opacity: 0 },
                    { transform: 'translateX(0)', opacity: 1 }
                ],
                options: {
                    duration: 300,
                    easing: 'ease-out',
                    fill: 'forwards'
                }
            },
            slideInRight: {
                keyframes: [
                    { transform: 'translateX(20px)', opacity: 0 },
                    { transform: 'translateX(0)', opacity: 1 }
                ],
                options: {
                    duration: 300,
                    easing: 'ease-out',
                    fill: 'forwards'
                }
            },
            slideOutLeft: {
                keyframes: [
                    { transform: 'translateX(0)', opacity: 1 },
                    { transform: 'translateX(-20px)', opacity: 0 }
                ],
                options: {
                    duration: 300,
                    easing: 'ease-in',
                    fill: 'forwards'
                }
            },
            slideOutRight: {
                keyframes: [
                    { transform: 'translateX(0)', opacity: 1 },
                    { transform: 'translateX(20px)', opacity: 0 }
                ],
                options: {
                    duration: 300,
                    easing: 'ease-in',
                    fill: 'forwards'
                }
            },
            
            // 패널 슬라이드 애니메이션
            slideIn: {
                keyframes: [
                    { transform: 'translateX(100%)', opacity: 0 },
                    { transform: 'translateX(0)', opacity: 1 }
                ],
                options: {
                    duration: 300,
                    easing: 'cubic-bezier(0.21, 0.61, 0.35, 1)',
                    fill: 'forwards'
                }
            },
            slideOut: {
                keyframes: [
                    { transform: 'translateX(0)', opacity: 1 },
                    { transform: 'translateX(100%)', opacity: 0 }
                ],
                options: {
                    duration: 300,
                    easing: 'cubic-bezier(0.55, 0.06, 0.68, 0.19)',
                    fill: 'forwards'
                }
            },
            
            // 확대/축소 애니메이션
            zoomIn: {
                keyframes: [
                    { transform: 'scale(0.9)', opacity: 0 },
                    { transform: 'scale(1)', opacity: 1 }
                ],
                options: {
                    duration: 300,
                    easing: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
                    fill: 'forwards'
                }
            },
            zoomOut: {
                keyframes: [
                    { transform: 'scale(1)', opacity: 1 },
                    { transform: 'scale(0.9)', opacity: 0 }
                ],
                options: {
                    duration: 300,
                    easing: 'cubic-bezier(0.36, 0, 0.66, -0.56)',
                    fill: 'forwards'
                }
            },
            
            // 흔들림 애니메이션
            shake: {
                keyframes: [
                    { transform: 'translateX(0)' },
                    { transform: 'translateX(-5px)' },
                    { transform: 'translateX(5px)' },
                    { transform: 'translateX(-5px)' },
                    { transform: 'translateX(5px)' },
                    { transform: 'translateX(-3px)' },
                    { transform: 'translateX(3px)' },
                    { transform: 'translateX(0)' }
                ],
                options: {
                    duration: 500,
                    easing: 'ease-in-out',
                    fill: 'forwards'
                }
            },
            
            // 바운스 애니메이션
            bounce: {
                keyframes: [
                    { transform: 'translateY(0)' },
                    { transform: 'translateY(-10px)' },
                    { transform: 'translateY(0)' },
                    { transform: 'translateY(-5px)' },
                    { transform: 'translateY(0)' }
                ],
                options: {
                    duration: 800,
                    easing: 'cubic-bezier(0.28, 0.84, 0.42, 1)',
                    fill: 'forwards'
                }
            },
            
            // 펄스 애니메이션
            pulse: {
                keyframes: [
                    { transform: 'scale(1)' },
                    { transform: 'scale(1.05)' },
                    { transform: 'scale(1)' }
                ],
                options: {
                    duration: 600,
                    easing: 'ease-in-out',
                    fill: 'forwards'
                }
            }
        };
        
        // 실행 중인 애니메이션 맵
        this.runningAnimations = new Map();
        
        // 저사양 장치 감지
        this.isLowPowerDevice = this.detectLowPowerDevice();
    }
    
    /**
     * 저사양 장치 감지
     * @returns {boolean} - 저사양 장치 여부
     */
    detectLowPowerDevice() {
        // 장치 메모리 확인 (2GB 미만이면 저사양으로 간주)
        if (navigator.deviceMemory && navigator.deviceMemory < 2) {
            return true;
        }
        
        // 모바일 장치 확인
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // 하드웨어 동시 실행 확인
        const hardwareConcurrency = navigator.hardwareConcurrency || 2;
        
        // 2코어 이하 모바일 장치는 저사양으로 간주
        if (isMobile && hardwareConcurrency <= 2) {
            return true;
        }
        
        // 축소된 동작 설정 확인
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        
        return prefersReducedMotion;
    }
    
    /**
     * 애니메이션 실행
     * @param {string} animationName - 실행할 애니메이션 이름
     * @param {HTMLElement} element - 애니메이션을 적용할 요소
     * @param {Object} customOptions - 커스텀 옵션 (콜백 포함)
     * @returns {Animation} - 생성된 애니메이션 객체
     */
    animate(animationName, element, customOptions = {}) {
        // 애니메이션 정보 가져오기
        const animation = this.animations[animationName];
        if (!animation) {
            console.error(`애니메이션 '${animationName}'을 찾을 수 없습니다.`);
            return null;
        }
        
        // 요소 확인
        if (!element || !(element instanceof HTMLElement)) {
            console.error('유효한 HTML 요소가 필요합니다.');
            return null;
        }
        
        // 이미 실행 중인 애니메이션 취소
        const runningAnimation = this.runningAnimations.get(element);
        if (runningAnimation) {
            runningAnimation.cancel();
            this.runningAnimations.delete(element);
        }
        
        // 저사양 장치인 경우 애니메이션 건너뛰기
        if (this.isLowPowerDevice) {
            // 즉시 최종 상태로 설정
            const finalKeyframe = animation.keyframes[animation.keyframes.length - 1];
            Object.assign(element.style, finalKeyframe);
            
            // 완료 콜백 실행
            if (customOptions.onComplete) {
                setTimeout(customOptions.onComplete, 0);
            }
            
            return null;
        }
        
        // 기본 옵션과 커스텀 옵션 병합
        const options = { ...animation.options };
        
        // 콜백 함수 제외한 나머지 옵션 병합
        for (const key in customOptions) {
            if (key !== 'onComplete' && key !== 'onStart' && key !== 'onUpdate') {
                options[key] = customOptions[key];
            }
        }
        
        // Web Animations API를 사용한 애니메이션 생성
        const webAnimation = element.animate(animation.keyframes, options);
        
        // 애니메이션 이벤트 리스너 추가
        if (customOptions.onStart) {
            webAnimation.onstart = customOptions.onStart;
        }
        
        if (customOptions.onUpdate) {
            webAnimation.onupdate = customOptions.onUpdate;
        }
        
        if (customOptions.onComplete) {
            webAnimation.onfinish = customOptions.onComplete;
        }
        
        // 실행 중인 애니메이션 맵에 추가
        this.runningAnimations.set(element, webAnimation);
        
        // 애니메이션 완료 후 맵에서 제거
        webAnimation.onfinish = () => {
            this.runningAnimations.delete(element);
            
            // 사용자 정의 완료 콜백 실행
            if (customOptions.onComplete) {
                customOptions.onComplete();
            }
        };
        
        return webAnimation;
    }
    
    /**
     * 요소의 모든 애니메이션 중단
     * @param {HTMLElement} element - 애니메이션을 중단할 요소
     */
    stopAnimation(element) {
        const runningAnimation = this.runningAnimations.get(element);
        if (runningAnimation) {
            runningAnimation.cancel();
            this.runningAnimations.delete(element);
        }
    }
    
    /**
     * 여러 요소에 순차적 애니메이션 적용
     * @param {string} animationName - 실행할 애니메이션 이름
     * @param {NodeList} elements - 애니메이션을 적용할 요소들
     * @param {number} delay - 요소 간 지연 시간 (밀리초)
     * @param {Object} customOptions - 커스텀 옵션
     */
    animateSequentially(animationName, elements, delay = 50, customOptions = {}) {
        // 저사양 장치인 경우 첫 번째와 마지막 요소만 애니메이션 적용
        if (this.isLowPowerDevice) {
            if (elements.length > 0) {
                this.animate(animationName, elements[0], customOptions);
                
                if (elements.length > 1) {
                    setTimeout(() => {
                        this.animate(animationName, elements[elements.length - 1], customOptions);
                    }, delay);
                }
            }
            return;
        }
        
        // 모든 요소에 순차적으로 애니메이션 적용
        Array.from(elements).forEach((element, index) => {
            setTimeout(() => {
                this.animate(animationName, element, customOptions);
            }, index * delay);
        });
    }
    
    /**
     * 테마 전환 애니메이션
     * @param {boolean} isDarkMode - 다크 모드로 전환 여부
     */
    animateThemeTransition(isDarkMode) {
        // 루트 요소
        const root = document.documentElement;
        
        // 오버레이 생성
        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.backgroundColor = isDarkMode ? 'rgba(0, 0, 0, 0)' : 'rgba(255, 255, 255, 0)';
        overlay.style.zIndex = '9999';
        overlay.style.pointerEvents = 'none';
        overlay.style.transition = 'background-color 500ms ease';
        
        document.body.appendChild(overlay);
        
        // 약간의 지연 후 배경색 변경
        setTimeout(() => {
            overlay.style.backgroundColor = isDarkMode ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.8)';
            
            // 애니메이션 완료 후 제거
            setTimeout(() => {
                overlay.style.backgroundColor = isDarkMode ? 'rgba(0, 0, 0, 0)' : 'rgba(255, 255, 255, 0)';
                
                setTimeout(() => {
                    overlay.remove();
                }, 500);
            }, 500);
        }, 50);
    }
}

// 전역 인스턴스 생성
const animationsController = new AnimationsController();
