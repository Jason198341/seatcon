/**
 * 데이터베이스 서비스
 * 
 * Supabase를 사용하여 실시간 데이터 동기화 및 사용자 관리 기능을 제공합니다.
 */
class DatabaseService {
    constructor() {
        this.supabaseUrl = 'https://veudhigojdukbqfgjeyh.supabase.co';
        this.supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZldWRoaWdvamR1a2JxZmdqZXloIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDUzODgwNjIsImV4cCI6MjA2MDk2NDA2Mn0.Vh0TUArZacAuRiLeoxml26u9GJxSOrziUhC3vURJVao';
        this.roomId = 'conference-chat-room';
        this.currentUser = null;
        this.messageSubscription = null;
        this.presenceSubscription = null;
        this.onlineUsers = new Map();
        this.tempMessages = new Map(); // 임시 메시지 저장소
        this.reconnectAttempts = 0; // 재연결 시도 횟수
        this.reconnectMaxAttempts = 10; // 최대 재연결 시도 횟수
        this.reconnectBaseDelay = 1000; // 기본 재연결 대기 시간 (1초)
        
        this.init();
    }
    
    /**
     * Supabase 클라이언트를 초기화합니다.
     */
    init() {
        if (typeof supabase === 'undefined') {
            console.error('Supabase 라이브러리를 로드하지 못했습니다.');
            alert('Supabase 라이브러리를 로드할 수 없습니다. 페이지를 새로고침하세요.');
            return;
        }
        
        try {
            this.client = supabase.createClient(this.supabaseUrl, this.supabaseKey);
            console.log('Supabase 클라이언트 초기화 완료');
            
            // 초기화 후 테이블 생성 시도
            this.createTables().then(() => {
                console.log('데이터베이스 테이블 설정 완료');
            }).catch(error => {
                console.error('데이터베이스 테이블 설정 실패:', error);
            });
            
            // 저장된 사용자 확인
            const savedUser = this.getSavedUserInfo();
            if (savedUser) {
                this.currentUser = savedUser;
            }

            // 네트워크 상태 모니터링
            this.setupNetworkMonitoring();
        } catch (error) {
            console.error('Supabase 클라이언트 초기화 실패:', error);
            alert('채팅 서비스 연결에 실패했습니다. 페이지를 새로고침하세요.');
        }
    }

    /**
     * 네트워크 상태 모니터링 설정
     */
    setupNetworkMonitoring() {
        window.addEventListener('online', () => {
            console.log('네트워크 연결 복원. 구독 재설정 중...');
            // 이미 존재하는 구독 해제
            this.unsubscribeAll();
            // 구독 재설정 - 콜백 함수는 앱에서 다시 설정해야 함
            if (window.app && typeof window.app.handleNewMessage === 'function') {
                this.subscribeToMessages(window.app.handleNewMessage.bind(window.app));
            }
            // Presence 구독 재설정
            if (this.currentUser) {
                this.subscribeToPresence();
            }
            // 네트워크 복원 알림
            if (window.uiController) {
                window.uiController.showToast('네트워크 연결이 복원되었습니다.', 'success');
            }
            // 재연결 시도 횟수 초기화
            this.reconnectAttempts = 0;
        });

        window.addEventListener('offline', () => {
            console.log('네트워크 연결 끊김.');
            if (window.uiController) {
                window.uiController.showToast('네트워크 연결이 끊겼습니다. 메시지가 전송되지 않을 수 있습니다.', 'warning');
            }
        });
    }
    
    /**
     * 데이터베이스 테이블을 생성합니다.
     */
    async createTables() {
        // 먼저 테이블을 수동으로 생성해봅니다
        try {
            // 실행할 SQL 쿼리 (테이블 생성)
            const createTablesSQL = `
                -- uuid 확장 활성화
                CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

                -- 메시지 테이블 생성
                CREATE TABLE IF NOT EXISTS messages (
                    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
                    room_id TEXT NOT NULL,
                    user_id TEXT NOT NULL,
                    user_name TEXT NOT NULL,
                    content TEXT NOT NULL,
                    language TEXT NOT NULL,
                    is_moderator BOOLEAN DEFAULT FALSE,
                    is_announcement BOOLEAN DEFAULT FALSE,
                    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                    client_id TEXT -- 클라이언트 측 임시 ID 저장 필드 추가
                );

                -- 강퇴된 사용자 테이블 생성
                CREATE TABLE IF NOT EXISTS kicked_users (
                    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
                    room_id TEXT NOT NULL,
                    user_id TEXT NOT NULL,
                    kicked_by TEXT NOT NULL,
                    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                    UNIQUE (room_id, user_id)
                );

                -- 인덱스 생성
                CREATE INDEX IF NOT EXISTS idx_messages_room_id ON messages(room_id);
                CREATE INDEX IF NOT EXISTS idx_messages_created_at ON messages(created_at);
                CREATE INDEX IF NOT EXISTS idx_messages_client_id ON messages(client_id);
            `;
            
            // SQL 직접 실행 시도
            const { error } = await this.client.rpc('exec_sql', { sql: createTablesSQL });
            
            if (error) {
                console.warn('SQL 직접 실행 실패(정상적인 상황일 수 있음):', error);
                // 테이블이 이미 존재하는지 확인
                return this.checkTables();
            }
            
            console.log('테이블 생성 SQL 실행 성공');
            return true;
            
        } catch (error) {
            console.error('테이블 생성 시도 실패:', error);
            // 테이블이 이미 존재하는지 확인
            return this.checkTables();
        }
    }
    
    /**
     * 테이블이 존재하는지 확인합니다.
     */
    async checkTables() {
        try {
            // messages 테이블 확인
            const { data: messagesData, error: messagesError } = await this.client
                .from('messages')
                .select('id')
                .limit(1);
            
            if (messagesError) {
                console.error('메시지 테이블 확인 실패:', messagesError);
                // 테이블이 없으면 직접 insert 시도 (Supabase가 자동으로 테이블 생성)
                await this.tryCreateTableWithInsert();
                return false;
            }
            
            // kicked_users 테이블 확인
            const { data: kickedData, error: kickedError } = await this.client
                .from('kicked_users')
                .select('id')
                .limit(1);
            
            if (kickedError) {
                console.error('강퇴 테이블 확인 실패:', kickedError);
                // 테이블이 없으면 직접 insert 시도
                await this.tryCreateKickedTableWithInsert();
                return false;
            }
            
            console.log('테이블이 모두 존재합니다');
            return true;
        } catch (error) {
            console.error('테이블 확인 중 오류:', error);
            return false;
        }
    }
    
    /**
     * Insert 명령으로 테이블 생성을 시도합니다.
     */
    async tryCreateTableWithInsert() {
        try {
            const { error } = await this.client
                .from('messages')
                .insert({
                    room_id: 'setup',
                    user_id: 'system',
                    user_name: 'System',
                    content: '테이블 설정 메시지',
                    language: 'ko',
                    is_moderator: true,
                    is_announcement: true,
                    client_id: `system-${Date.now()}`
                });
            
            if (error) {
                console.error('Insert로 메시지 테이블 생성 실패:', error);
                return false;
            }
            
            console.log('Insert로 메시지 테이블 생성 성공');
            return true;
        } catch (error) {
            console.error('Insert로 테이블 생성 시도 중 오류:', error);
            return false;
        }
    }
    
    /**
     * Insert 명령으로 강퇴 테이블 생성을 시도합니다.
     */
    async tryCreateKickedTableWithInsert() {
        try {
            const { error } = await this.client
                .from('kicked_users')
                .insert({
                    room_id: 'setup',
                    user_id: 'system',
                    kicked_by: 'system'
                });
            
            if (error) {
                console.error('Insert로 강퇴 테이블 생성 실패:', error);
                return false;
            }
            
            console.log('Insert로 강퇴 테이블 생성 성공');
            return true;
        } catch (error) {
            console.error('Insert로 강퇴 테이블 생성 시도 중 오류:', error);
            return false;
        }
    }
    
    /**
     * 로컬 스토리지에서 사용자 정보를 가져옵니다.
     */
    getSavedUserInfo() {
        try {
            const userInfo = localStorage.getItem('conferenceUserInfo');
            return userInfo ? JSON.parse(userInfo) : null;
        } catch (error) {
            console.error('사용자 정보 로드 실패:', error);
            return null;
        }
    }
    
    /**
     * 사용자 정보를 로컬 스토리지에 저장합니다.
     */
    saveUserInfo(userInfo) {
        try {
            this.currentUser = userInfo;
            localStorage.setItem('conferenceUserInfo', JSON.stringify(userInfo));
        } catch (error) {
            console.error('사용자 정보 저장 실패:', error);
        }
    }
    
    /**
     * 사용자 정보를 제거합니다.
     */
    clearUserInfo() {
        this.currentUser = null;
        localStorage.removeItem('conferenceUserInfo');
    }
    
    /**
     * 메시지를 전송합니다.
     * @param {string} content - 메시지 내용
     * @param {boolean} isAnnouncement - 공지사항 여부
     * @returns {Promise<Object>} - 전송된 메시지 객체
     */
    async sendMessage(content, isAnnouncement = false) {
        if (!this.currentUser || !content.trim()) {
            return null;
        }
        
        try {
            // 언어 감지
            const detectedLanguage = await translationService.detectLanguage(content) || this.currentUser.language;
            
            // 임시 메시지 ID 생성 - 클라이언트 측과 서버 측 메시지 매칭에 사용
            const clientId = `client-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            // 임시 메시지 객체 생성 (UI 즉시 표시용)
            const tempMessage = {
                id: clientId,
                room_id: this.roomId,
                user_id: this.currentUser.email,
                user_name: this.currentUser.name,
                content: content,
                language: detectedLanguage,
                is_moderator: this.currentUser.isModerator,
                is_announcement: isAnnouncement,
                created_at: new Date().toISOString(),
                isTemp: true, // 임시 메시지 플래그
                client_id: clientId
            };
            
            // 임시 메시지 저장
            this.tempMessages.set(clientId, tempMessage);
            
            // 메시지 전송 시도 전에 UI에 임시 메시지 표시
            // app.js의 handleNewMessage 함수가 이를 처리하도록 호출
            window.app.handleNewMessage(tempMessage);
            
            // 오프라인 상태 체크
            if (!navigator.onLine) {
                console.warn('오프라인 상태에서 메시지 전송 시도. 메시지를 큐에 추가합니다.');
                // 오프라인 큐에 메시지 추가 로직 구현 가능
                // 현재는 단순히 오류 처리
                throw new Error('네트워크 연결이 없습니다. 메시지를 전송할 수 없습니다.');
            }
            
            // 메시지 전송 시도
            const { data, error } = await this.client
                .from('messages')
                .insert([
                    {
                        room_id: this.roomId,
                        user_id: this.currentUser.email,
                        user_name: this.currentUser.name,
                        content: content,
                        language: detectedLanguage,
                        is_moderator: this.currentUser.isModerator,
                        is_announcement: isAnnouncement,
                        client_id: clientId // 클라이언트 ID 저장하여 임시 메시지와 매칭
                    }
                ])
                .select();
                
            if (error) {
                // 테이블이 없는 경우 생성 후 재시도
                if (error.code === '42P01' || error.message.includes('does not exist')) {
                    await this.createTables();
                    return this.sendMessage(content, isAnnouncement);
                }
                
                console.error('메시지 삽입 오류:', error);
                
                // 임시 메시지를 오류 상태로 업데이트
                tempMessage.error = true;
                tempMessage.errorMessage = error.message;
                window.app.handleMessageError(clientId, error.message);
                
                throw error;
            }
            
            console.log('메시지 전송 성공:', data[0]);
            
            // 임시 메시지 교체 로직은 subscribeToMessages에서 처리
            
            return data[0];
        } catch (error) {
            console.error('메시지 전송 실패:', error);
            
            // UI에 오류 표시
            if (window.uiController) {
                window.uiController.showToast('메시지 전송에 실패했습니다.', 'error');
            }
            
            throw new Error(`메시지 전송 실패: ${error.message || '알 수 없는 오류'}`);
        }
    }
    
    /**
     * 최근 메시지를 가져옵니다.
     * @param {number} limit - 가져올 메시지 수
     * @returns {Promise<Array>} - 메시지 배열
     */
    async getRecentMessages(limit = 50) {
        try {
            const { data, error } = await this.client
                .from('messages')
                .select('*')
                .eq('room_id', this.roomId)
                .order('created_at', { ascending: false })
                .limit(limit);
                
            if (error) {
                // 테이블이 없는 경우 빈 배열 반환
                if (error.code === '42P01' || error.message.includes('does not exist')) {
                    await this.createTables();
                    return [];
                }
                throw error;
            }
            
            // 시간 순으로 정렬
            const messages = data.reverse();
            console.log(`최근 메시지 ${messages.length}개 로드 완료`);
            return messages;
        } catch (error) {
            console.error('메시지 로드 실패:', error);
            return [];
        }
    }
    
    /**
     * 실시간 메시지 업데이트를 구독합니다.
     * @param {Function} callback - 새 메시지 발생 시 호출될 콜백 함수
     */
    subscribeToMessages(callback) {
        if (this.messageSubscription) {
            this.messageSubscription.unsubscribe();
        }
        
        console.log('메시지 구독 시작 시도...');
        
        try {
            // 채널 이름에 room_id 포함하여 구체적으로 정의
            const channelName = `room-${this.roomId}`;
            
            this.messageSubscription = this.client
                .channel(channelName)
                .on('postgres_changes', 
                    { 
                        event: 'INSERT', 
                        schema: 'public', 
                        table: 'messages',
                        filter: `room_id=eq.${this.roomId}` // 특정 room_id에 대한 필터 추가
                    }, 
                    async payload => {
                        const message = payload.new;
                        console.log('새 메시지 수신:', message);
                        
                        // 임시 메시지와 매칭 확인
                        const isMatchingTemp = message.client_id && this.tempMessages.has(message.client_id);
                        
                        // 이미 표시된 임시 메시지가 있는 경우, UI 업데이트 처리
                        if (isMatchingTemp) {
                            const tempMessage = this.tempMessages.get(message.client_id);
                            
                            // 임시 메시지 참조 제거
                            this.tempMessages.delete(message.client_id);
                            
                            // tempMessage.id와 실제 message.id가 다르므로 UI에서 교체 작업 필요
                            window.app.updateTempMessage(tempMessage.id, message);
                            
                            // 번역이 필요한 경우 별도 처리
                            if (this.currentUser && this.currentUser.language !== message.language) {
                                this.translateAndUpdateMessage(message, callback);
                            }
                            
                            // 임시 메시지가 이미 처리되었으므로 더 이상의 처리 불필요
                            return;
                        }
                        
                        // 새로운 메시지 (다른 사용자로부터) 또는 매칭되지 않은 자신의 메시지
                        if (this.currentUser && this.currentUser.language !== message.language) {
                            await this.translateAndUpdateMessage(message, callback);
                        } else {
                            // 번역 필요 없는 경우 바로 콜백 호출
                            callback(message);
                        }
                    }
                )
                .subscribe((status) => {
                    console.log('메시지 구독 상태:', status);
                    if (status === 'SUBSCRIBED') {
                        console.log('메시지 구독이 성공적으로 활성화되었습니다');
                        // 구독 성공시 재시도 카운터 리셋
                        this.reconnectAttempts = 0;
                    } else if (status === 'CHANNEL_ERROR') {
                        console.error('메시지 구독 중 채널 오류가 발생했습니다');
                        // 지수 백오프를 사용한 재시도
                        this.reconnectWithExponentialBackoff(callback);
                    }
                });
                
            console.log('메시지 구독 시작 완료');
        } catch (error) {
            console.error('메시지 구독 시작 실패:', error);
            // UI에 오류 표시
            if (window.uiController) {
                window.uiController.showToast('실시간 메시지 수신에 문제가 발생했습니다.', 'error');
            }
            
            // 지수 백오프를 사용한 재시도
            this.reconnectWithExponentialBackoff(callback);
        }
    }
    
    /**
     * 메시지를 번역하고 업데이트합니다.
     * @param {Object} message - 메시지 객체
     * @param {Function} callback - 콜백 함수
     */
    async translateAndUpdateMessage(message, callback) {
        try {
            const translatedContent = await translationService.translateText(
                message.content,
                message.language,
                this.currentUser.language
            );
            
            message.translatedContent = translatedContent;
            message.targetLanguage = this.currentUser.language;
            
            // 번역 완료 후 콜백 호출
            callback(message);
        } catch (error) {
            console.error('메시지 번역 실패:', error);
            // 번역 실패해도 원본 메시지는 표시
            callback(message);
        }
    }
    
    /**
     * 지수 백오프 방식으로 재연결을 시도합니다.
     * @param {Function} callback - 메시지 콜백 함수
     */
    reconnectWithExponentialBackoff(callback) {
        if (this.reconnectAttempts >= this.reconnectMaxAttempts) {
            console.error('최대 재연결 시도 횟수를 초과했습니다.');
            if (window.uiController) {
                window.uiController.showToast('채팅 서버에 연결할 수 없습니다. 페이지를 새로고침하세요.', 'error');
            }
            return;
        }
        
        // 지수 백오프 계산 (1초, 2초, 4초, 8초, ...)
        const delay = this.reconnectBaseDelay * Math.pow(2, this.reconnectAttempts);
        console.log(`${delay}ms 후 재연결 시도... (시도 ${this.reconnectAttempts + 1}/${this.reconnectMaxAttempts})`);
        
        setTimeout(() => {
            this.reconnectAttempts++;
            this.subscribeToMessages(callback);
        }, delay);
    }
    
    /**
     * 실시간 사용자 상태 업데이트를 구독합니다.
     * @param {Function} callback - 사용자 상태 변경 시 호출될 콜백 함수
     */
    subscribeToPresence(callback) {
        if (this.presenceSubscription) {
            this.presenceSubscription.unsubscribe();
        }
        
        try {
            // room_id를 포함한 채널 이름 사용
            const channelName = `presence-${this.roomId}`;
            
            this.presenceSubscription = this.client
                .channel(channelName)
                .on('presence', { event: 'sync' }, () => {
                    const presence = this.presenceSubscription.presenceState();
                    const users = new Map();
                    
                    for (const [key, value] of Object.entries(presence)) {
                        if (value && value.length > 0) {
                            const user = value[0];
                            users.set(user.user_id, user);
                        }
                    }
                    
                    this.onlineUsers = users;
                    if (callback) callback(Array.from(users.values()));
                })
                .on('presence', { event: 'join' }, ({ key, newPresences }) => {
                    for (const presence of newPresences) {
                        this.onlineUsers.set(presence.user_id, presence);
                        
                        // 새 사용자 입장 알림 표시
                        if (window.uiController && presence.user_id !== this.currentUser.email) {
                            window.uiController.addSystemMessage(`${presence.user_name}님이 채팅에 참여했습니다.`);
                        }
                    }
                    
                    if (callback) callback(Array.from(this.onlineUsers.values()));
                })
                .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
                    for (const presence of leftPresences) {
                        // 사용자 퇴장 알림 표시
                        if (window.uiController && this.onlineUsers.has(presence.user_id) && 
                            presence.user_id !== this.currentUser.email) {
                            window.uiController.addSystemMessage(`${presence.user_name}님이 채팅을 나갔습니다.`);
                        }
                        
                        this.onlineUsers.delete(presence.user_id);
                    }
                    
                    if (callback) callback(Array.from(this.onlineUsers.values()));
                })
                .subscribe(async status => {
                    console.log('상태 구독 상태:', status);
                    if (status !== 'SUBSCRIBED' || !this.currentUser) return;
                    
                    // 자신의 상태 공유
                    await this.presenceSubscription.track({
                        user_id: this.currentUser.email,
                        user_name: this.currentUser.name,
                        is_moderator: this.currentUser.isModerator,
                        language: this.currentUser.language,
                        online_at: new Date().toISOString()
                    });
                });
                
            console.log('상태 구독 시작');
        } catch (error) {
            console.error('상태 구독 시작 실패:', error);
        }
    }
    
    /**
     * 구독을 모두 해제합니다.
     */
    unsubscribeAll() {
        if (this.messageSubscription) {
            this.messageSubscription.unsubscribe();
            this.messageSubscription = null;
        }
        
        if (this.presenceSubscription) {
            this.presenceSubscription.unsubscribe();
            this.presenceSubscription = null;
        }
        
        console.log('모든 구독 해제');
    }
    
    /**
     * 사용자 강퇴 기능
     * @param {string} userEmail - 강퇴할 사용자 이메일
     * @returns {Promise<boolean>} - 성공 여부
     */
    async kickUser(userEmail) {
        if (!this.currentUser || !this.currentUser.isModerator) {
            console.error('진행자만 사용자를 강퇴할 수 있습니다.');
            return false;
        }
        
        try {
            const { data, error } = await this.client
                .from('kicked_users')
                .insert([
                    {
                        room_id: this.roomId,
                        user_id: userEmail,
                        kicked_by: this.currentUser.email
                    }
                ]);
                
            if (error) {
                // 테이블이 없는 경우 생성 후 재시도
                if (error.code === '42P01' || error.message.includes('does not exist')) {
                    await this.createTables();
                    return this.kickUser(userEmail);
                }
                throw error;
            }
            
            // 강퇴 알림 메시지 전송
            await this.sendMessage(`${userEmail} 사용자가 강퇴되었습니다.`, true);
            
            console.log('사용자 강퇴 성공:', userEmail);
            return true;
        } catch (error) {
            console.error('사용자 강퇴 실패:', error);
            return false;
        }
    }
    
    /**
     * 사용자가 강퇴되었는지 확인합니다.
     * @returns {Promise<boolean>} - 강퇴 여부
     */
    async checkIfKicked() {
        if (!this.currentUser) return false;
        
        try {
            const { data, error } = await this.client
                .from('kicked_users')
                .select('*')
                .eq('room_id', this.roomId)
                .eq('user_id', this.currentUser.email)
                .limit(1);
                
            if (error) {
                // 테이블이 없는 경우는 강퇴 아님
                if (error.code === '42P01' || error.message.includes('does not exist')) {
                    return false;
                }
                throw error;
            }
            
            if (data && data.length > 0) {
                console.log('현재 사용자가 강퇴되었습니다.');
                return true;
            }
            
            return false;
        } catch (error) {
            console.error('강퇴 확인 실패:', error);
            return false;
        }
    }
    
    /**
     * API 연결 테스트를 수행합니다.
     */
    async testConnection() {
        try {
            const { data, error } = await this.client.from('messages').select('count(*)', { count: 'exact', head: true });
            
            if (error) {
                if (error.code === '42P01' || error.message.includes('does not exist')) {
                    console.log('테이블이 존재하지 않습니다. 생성을 시도합니다.');
                    await this.createTables();
                    return true;
                }
                throw error;
            }
            
            console.log('Supabase 연결 테스트 성공');
            return true;
        } catch (error) {
            console.error('Supabase 연결 테스트 실패:', error);
            return false;
        }
    }
    
    /**
     * 임시 메시지를 실패 상태로 표시합니다.
     * @param {string} clientId - 임시 메시지 ID
     * @param {string} errorMessage - 오류 메시지
     */
    markMessageAsFailed(clientId, errorMessage) {
        if (this.tempMessages.has(clientId)) {
            const tempMessage = this.tempMessages.get(clientId);
            tempMessage.error = true;
            tempMessage.errorMessage = errorMessage;
            
            // UI 업데이트
            if (window.app && typeof window.app.handleMessageError === 'function') {
                window.app.handleMessageError(clientId, errorMessage);
            }
        }
    }
    
    /**
     * 실패한 메시지를 재시도합니다.
     * @param {string} clientId - 임시 메시지 ID
     * @returns {Promise<boolean>} - 성공 여부
     */
    async retryMessage(clientId) {
        if (!this.tempMessages.has(clientId)) {
            console.error('재시도할 메시지를 찾을 수 없습니다:', clientId);
            return false;
        }
        
        const tempMessage = this.tempMessages.get(clientId);
        
        try {
            // 메시지 전송 상태 업데이트
            tempMessage.error = false;
            tempMessage.isRetrying = true;
            
            // UI 업데이트
            if (window.app && typeof window.app.updateMessageStatus === 'function') {
                window.app.updateMessageStatus(clientId, { isRetrying: true });
            }
            
            // 메시지 재전송
            const { data, error } = await this.client
                .from('messages')
                .insert([
                    {
                        room_id: this.roomId,
                        user_id: tempMessage.user_id,
                        user_name: tempMessage.user_name,
                        content: tempMessage.content,
                        language: tempMessage.language,
                        is_moderator: tempMessage.is_moderator,
                        is_announcement: tempMessage.is_announcement,
                        client_id: clientId
                    }
                ])
                .select();
                
            if (error) {
                throw error;
            }
            
            console.log('메시지 재전송 성공:', data[0]);
            
            // 임시 메시지 상태 업데이트
            tempMessage.isRetrying = false;
            tempMessage.retrySuccess = true;
            
            return true;
        } catch (error) {
            console.error('메시지 재전송 실패:', error);
            
            // 임시 메시지 상태 업데이트
            tempMessage.error = true;
            tempMessage.isRetrying = false;
            tempMessage.errorMessage = error.message || '메시지 재전송 실패';
            
            // UI 업데이트
            if (window.app && typeof window.app.handleMessageError === 'function') {
                window.app.handleMessageError(clientId, error.message);
            }
            
            return false;
        }
    }
    
    /**
     * 특정 채팅방의 참가자 목록을 가져옵니다.
     * @returns {Promise<Array>} - 참가자 목록
     */
    async getRoomParticipants() {
        // 현재는 온라인 사용자 목록을 반환
        return Array.from(this.onlineUsers.values());
    }
    
    /**
     * 사용자 입력 중 상태를 업데이트합니다.
     * @param {boolean} isTyping - 입력 중 여부
     */
    async updateTypingStatus(isTyping) {
        if (!this.currentUser || !this.presenceSubscription) return;
        
        try {
            await this.presenceSubscription.track({
                user_id: this.currentUser.email,
                user_name: this.currentUser.name,
                is_moderator: this.currentUser.isModerator,
                language: this.currentUser.language,
                is_typing: isTyping,
                online_at: new Date().toISOString()
            });
        } catch (error) {
            console.error('입력 상태 업데이트 실패:', error);
        }
    }
    
    /**
     * 메시지 읽음 상태를 업데이트합니다.
     * @param {string} messageId - 메시지 ID
     */
    async markMessageAsRead(messageId) {
        // 향후 구현 예정
        // 현재는 로그만 출력
        console.log('메시지 읽음 표시:', messageId);
    }
}

// 전역 인스턴스 생성
const databaseService = new DatabaseService();
